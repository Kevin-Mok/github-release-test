@Library('jenkins-pipeline-shared-libraries')_

deployProperties = [:]
pipeline {
    agent { label 'kie-rhel7-priority' }
    parameters {
        string(name: 'DISPLAY_NAME', defaultValue: '', description: 'Setup a specific build display name')
        string(name: 'BUILD_BRANCH_NAME', defaultValue: '7.1.1', description: 'Which branch to build? Set if you are not on a multibranch pipeline.')
        string(name: 'MAVEN_DEPLOY_REPOSITORY', defaultValue: '', description: 'Specify a Maven repository to deploy the artifacts.')
        string(name: 'GIT_AUTHOR', defaultValue: 'Kevin-Mok-Bot', description: 'Which Git author repository ?')
        booleanParam(name: 'RELEASE', defaultValue: false, description: 'Is this build for a release?')
        string(name: 'PROJECT_VERSION', defaultValue: '', description: 'Optional if not RELEASE. If RELEASE, cannot be empty.')

        // PR parameters to be filled out by GitHub Pull Request Builder for PR checks
        string(name: 'PR_TARGET_BRANCH', defaultValue: '', description: 'What is the target branch of the PR? Will be automatically filled out by GitHub Pull Request Builder.')
    }
    environment {
        MAVEN_OPTS = '-Xms1024m -Xmx4g'
        BOT_CREDENTIALS_ID = "bsig-gh-bot"
    }
    tools {
        maven 'kie-maven-3.6.2'
        jdk 'kie-jdk11'
    }
    options {
        buildDiscarder logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '', numToKeepStr: '5')
        timeout(time: 120, unit: 'MINUTES')
    }
    stages {
        stage("Initialize") {
            steps {
                script {
                    echo "clone test"
                    if (params.DISPLAY_NAME != "") {
                        currentBuild.displayName = params.DISPLAY_NAME
                    }

                    if (env.BRANCH_NAME != "") {
                        // Switch to branch if not on a multibranch pipeline
                        env.BRANCH_NAME = getBuildBranch()
                    }
                    if (isRelease()) {
                        assert getProjectVersion() != ''
                    }
                    setDeployPropertyIfNeeded('git.branch', getBuildBranch())
                    setDeployPropertyIfNeeded('project.version', getProjectVersion())
                    setDeployPropertyIfNeeded('release', isRelease())
                }
            }
        }
        /* stage('getForkedProjectName') { 
            steps {
                script {
                    def result = null
                    withCredentials([string(credentialsId: 'kie-ci1-token', variable: 'OAUTHTOKEN')]) {
                        def curlResult = sh(returnStdout: true, script: "curl -H \"Authorization: token ${OAUTHTOKEN}\" 'https://api.github.com/repos/kiegroup/${repository}/forks'")?.trim()
                        if (curlResult) {
                            def forkedProjects = readJSON text: curlResult
                            def forkedProject = forkedProjects.find { it.owner.login == owner }
                            result = forkedProject ? forkedProject.name : null
                        }
                    }
                }
            }
        } */
        stage('Clone repositories') { 
            steps {
                script {
                    def sourceRepository = githubscm.getForkedProjectName(defaultAuthor, repository, sourceAuthor, credentials['token']) ?: repository
                    /* githubscm.checkoutIfExists('jenkins-test', 'Kevin-Mok-Bot', '7.1.1', 'kiegroup', 'master', true) */
                    /* def repository = 'jenkins-test'
                    def author = 'Kevin-Mok-Bot'
                    def branches = '7.1.1'
                    def defaultAuthor = 'kiegroup'
                    def defaultBranches = 'master'
                    def mergeTarget = true
                    def credentials = ['token': 'kie-ci1-token', 'usernamePassword': 'kie-ci']

                    assert credentials['token']
                    assert credentials['usernamePassword']
                    def sourceAuthor = author
                    echo 'before fork'
                    def sourceRepository = githubscm.getForkedProjectName(defaultAuthor, repository, sourceAuthor, credentials['token']) ?: repository
                    echo 'after fork'
                    // Checks source group and branch (for cases where the branch has been created in the author's forked project)
                    def repositoryScm = githubscm.getRepositoryScm(sourceRepository, author, branches, credentials['usernamePassword'])
                    if (repositoryScm == null) {
                        // Checks target group and and source branch (for cases where the branch has been created in the target project itself
                        repositoryScm = githubscm.getRepositoryScm(repository, defaultAuthor, branches, credentials['usernamePassword'])
                        sourceAuthor = repositoryScm ? defaultAuthor : author
                    }
                    if (repositoryScm != null && githubscm.hasPullRequest(defaultAuthor, repository, author, branches, credentials['token'])) {
                        if (mergeTarget) {
                            githubscm.mergeSourceIntoTarget(sourceRepository, sourceAuthor, branches, repository, defaultAuthor, defaultBranches, credentials['usernamePassword'])
                        } else {
                            checkout repositoryScm
                        }
                    } else {
                        checkout(githubscm.resolveRepository(repository, defaultAuthor, defaultBranches, false, credentials['usernamePassword']))
                    } */
                }
            }
        }
    }
}

void saveReports(boolean allowEmpty=false){
    junit testResults: '**/target/surefire-reports/**/*.xml, **/target/failsafe-reports/**/*.xml', allowEmptyResults: allowEmpty
}

void cloneRepo(String repo, String dirName=repo) {
    dir(dirName) {
        deleteDir()
        githubscm.checkoutIfExists(repo, getGitAuthor(), getBuildBranch(), 'kiegroup', getDefaultBranch(repo), true)
    }
}

void prepareForPR(String repo) {
    dir(repo) {
        githubscm.forkRepo(env.BOT_CREDENTIALS_ID)
        githubscm.createBranch(getProjectVersion())
    }
}

void addNotIgnoredPoms() {
    // based on https://stackoverflow.com/a/59888964/8811872
    sh '''
    find . -type f -name 'pom.xml' > found_poms.txt
    poms_to_add=""
    while IFS= read -r pom; do
        if ! git check-ignore -q "\$pom"; then
            poms_to_add="\$poms_to_add \$pom"
        fi
    done < found_poms.txt
    rm found_poms.txt
    git add \$poms_to_add
    '''
}

void commitAndCreatePR(String repo) {
    def commitMsg = "Update project version to ${getProjectVersion()} for release"
    def prBody = "Generated by build ${BUILD_TAG}: ${BUILD_URL}"
    // Not using githubscm.commitChanges() because globbing won't work.
    // See: https://github.com/kiegroup/kogito-runtimes/pull/570#discussion_r449268738
    dir(repo) {
        addNotIgnoredPoms()
        sh "git commit -m '${commitMsg}'"
        githubscm.pushObject("origin", getProjectVersion(), env.BOT_CREDENTIALS_ID)
        deployProperties["${repo}.pr.link"] = githubscm.createPR(commitMsg, prBody, getBuildBranch(), env.BOT_CREDENTIALS_ID)
    }
}

boolean isRelease() {
    return params.RELEASE
}

String getGitAuthor(){
    return params.GIT_AUTHOR
}

String getBuildBranch(){
    return params.BUILD_BRANCH_NAME
}

String getProjectVersion(){
    return params.PROJECT_VERSION
}

void setDeployPropertyIfNeeded(String key, def value){
    if (value != null && value != ""){
        deployProperties[key] = value
    }
}

void mavenInstall(String directory, boolean skipTests = false, String... profiles) {
    installCmd = 'clean install'
    if(profiles.length > 0){
        installCmd += " -P${profiles.join(',')}"
    }
    dir(directory) {
        maven.runMavenWithSubmarineSettings(installCmd, skipTests)
    }
}

String getDefaultBranch(String repo) {
    // if not triggered by PR
    if (params.PR_TARGET_BRANCH == '') {
        return 'master'
    }
    // if PR target branch exists
    def repositoryScm = githubscm.getRepositoryScm(repo, 'kiegroup', params.PR_TARGET_BRANCH)
    if (repositoryScm != null) {
        return params.PR_TARGET_BRANCH
    }
    // if target branch doesn't exist in repos other than PR repo
    return 'master'
}

String getBotBranch(){
    return "${getProjectVersion()}-${env.BOT_BRANCH_HASH}"
}

String getBotAuthor(){
    return env.GIT_AUTHOR_BOT
}

void mavenCleanInstall(String directory, boolean skipTests = false, List profiles = [], String extraArgs = '') {
    runMaven('clean install', directory, skipTests, profiles, extraArgs)
}

void mavenDeploy(String directory) {
    extraArgs = params.MAVEN_DEPLOY_REPOSITORY != '' ? "-DaltDeploymentRepository=runtimes-artifacts::default::${params.MAVEN_DEPLOY_REPOSITORY}" : ''
    runMaven('clean deploy', directory, true, [], extraArgs)
}

void runMaven(String command, String directory, boolean skipTests = false, List profiles = [], String extraArgs = '') {
    mvnCmd = command
    if(profiles.size() > 0){
        mvnCmd += " -P${profiles.join(',')}"
    }
    if(extraArgs != ''){
        mvnCmd += " ${extraArgs}"
    }
    dir(directory) {
        maven.runMavenWithSubmarineSettings(mvnCmd, skipTests)
    }
}
